% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lscggm_xval.R
\name{lscggm.cv}
\alias{lscggm.cv}
\title{Perform K-fold cross-validation for the Conditional Low-Rank plus Sparse estimator}
\usage{
lscggm.cv(
  X,
  Z,
  gammas = c(0.05, 0.1, 0.15),
  covariance.estimator = cor,
  n.folds = 5,
  lambdas = NULL,
  lambda.max = NULL,
  lambda.ratio = 1e-04,
  n.lambdas = 20,
  max.sparsity = 0.5,
  max.rank = NA,
  abs_tol = 1e-05,
  rel_tol = 0.001,
  max.iter = 2000,
  mu = 1,
  verbose = FALSE,
  seed = NA
)
}
\arguments{
\item{X}{n x p data matrix}

\item{Z}{n x m data matrix of variables to condition on.}

\item{gammas}{A real or a vector of reals between 0 and 1 (non inclusive). For each value of gamma
the regularisation path is computed and cross-validation is performed. See examples for
guidance on how to choose reasonable values for gamma. Too high a value might result in the
problem being under-identified and therefore numerical instabilities.}

\item{covariance.estimator}{A function that takes a data matrix and outputs an estimate of its correlation matrix.
Default: the sample correlation matrix output by the \code{cor} function.}

\item{n.folds}{Number of folds for cross-validation. Default 5.}

\item{lambdas}{A decreasing sequence of values of lambda. See Details for the default values.}

\item{lambda.max}{A positive real. Maximum value of lambda. See Details.}

\item{lambda.ratio}{A real between 0 and 1. The smallest value of lambda is given by lambda.max * lambda.ratio. See Details.}

\item{n.lambdas}{A positive integer. The number of values of lambda to
generate according a geometric sequence between lambda.max and lambda.max * lambda.ratio. See Details.}

\item{max.sparsity}{A real between 0 and 1. Abort the computation of the path if S becomes denser than this value.}

\item{max.rank}{A real between 0 and 1. Abort the computuation of the path if the rank of L becomes higher than this value.}

\item{abs_tol}{\code{abs_tol} parameter of the \code{lrpsadmm} function.}

\item{rel_tol}{\code{rel_tol} parameter of the \code{lrpsadmm} function.}

\item{max.iter}{\code{max.iter} parameter of the \code{lrpsadmm} function.}

\item{mu}{\code{mu} parameter of the \code{lrpsadmm} function.}

\item{verbose}{A boolean. Whether to print the value of lambda, gamma, sparsity of S, etc... after each fit}

\item{seed}{Set the seed of the random number generator used for the K folds.}
}
\value{
An object of class lscggmadmmcv.
  It contains the values of the mean cross-validated log-likelihood, its standard deviation for each
  pair (lambda, gamma) and an object of class lscggmadmm.path for each value of gamma.
  See the examples for how to access the selected tuning parameters, best fit etc...
}
\description{
Performs K-fold cross-validation in order to select the tuning parameters
  lambda and gamma.

  Recall that the penalty for the LRpS estimator is written as \eqn{\lambda_1 ||S||_1 + \lambda_2 Trace(L)} in the
  objective function of \code{lrpsadmm}.
  This can be equivalently rewritten in terms of the regularisation parameters \eqn{\lambda} and \eqn{\gamma} as follows
  \deqn{\lambda \gamma ||S||_1 + \lambda (1 - \gamma) Trace(L),}
  for \eqn{\gamma \in (0, 1)}.

  For a given value of \eqn{\gamma}, one can perform cross-validation along the regularisation path in order to choose
  \eqn{\lambda}. This function computes the regularisation paths for each value of \eqn{\gamma} supplied as arguments
  and performs cross-validation. The pair (\eqn{\lambda, \gamma}) that produces the smallest cross-validated log-likelihood
  is returned.
}
\details{
Recall that the penalty for the LRpS estimator is written as \eqn{\lambda_1 ||S||_1 + \lambda_2 Trace(L)} in the
  objective function of \code{lrpsadmm}.
  This can be equivalently rewritten in terms of the regularisation parameters \eqn{\lambda} and \eqn{\gamma} as follows
  \deqn{\lambda \gamma ||S||_1 + \lambda (1 - \gamma) Trace(L),}
  for \eqn{\gamma \in (0, 1)}.

  For a given value of \eqn{\gamma}, one can perform cross-validation along the regularisation path in order to choose
  \eqn{\lambda}. This function computes the regularisation paths for each value of \eqn{\gamma} supplied as arguments
  and performs cross-validation. One can then select the pair (\eqn{\lambda, \gamma}) that produces the smallest
  cross-validated log-likelihood.

The function \code{lrpsadmm} is fitted for successive values of \eqn{\lambda} using warm starts.
The sequence of values of \eqn{\lambda} can be provided directly by the user.
It is automatically sorted in decreasing order.
By default, a decreasing sequence of 20 values within a reasonable range is selected as follows.
We set \eqn{\lambda_{max} = \max_{ij, i \neq j} |\Sigma_{ij}|/\gamma} and
\eqn{\lambda_{min} = \lambda_{max}} * \code{lambda.ratio}; then
20 values between \eqn{\lambda_{max}} and \eqn{\lambda_{min}} are taken following
a geometric progression.

Because it does not make much sense to fit this estimator when the sparse estimate S becomes too dense
or if the rank of the low-rank estimate L becomes too high, the computation of the path is aborted
when the sparsity of S reaches \code{max.sparsity} or when the rank of L reaches \code{max.rank}.

Recall that cross-validation overselects. It might be good for prediction purposes but methods such
statibility selection are probably better if the support of S is what is of interest.
}
\seealso{
lscggm lscggm.path
}
